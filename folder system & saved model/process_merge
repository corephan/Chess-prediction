%%writefile /content/ChessOutcomesPrediction/System/process_merge.py
import os
import random
import mmap
import gc
from tqdm import tqdm
import time

# =================================================================
# üéõÔ∏è C·∫§U H√åNH H·ªÜ TH·ªêNG
# =================================================================
BASE_DIR = "/content/ChessOutcomesPrediction"

# ƒê∆∞·ªùng d·∫´n file ƒë√£ ƒë∆∞·ª£c s·ª≠a l·ªói c√∫ ph√°p:
FILE_MAIN = os.path.join(BASE_DIR, 'DataSets', 'pgnData', '(1).pgn')
FILE_DRAW = os.path.join(BASE_DIR, 'DataSets', 'pgnData', 'all_draws_combined.pgn')
OUTPUT_DIR = os.path.join(BASE_DIR, 'DataSets', 'pgnData (Balanced)')

TARGET_PER_CLASS = 100000
RATIOS = (0.8, 0.1, 0.1)

def scan_pgn_indices_fast(file_path):
    """Qu√©t file si√™u t·ªëc d√πng mmap"""
    if not os.path.exists(file_path):
        print(f"‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y {file_path}")
        return {'1-0': [], '0-1': [], '1/2-1/2': []}

    indices = {'1-0': [], '0-1': [], '1/2-1/2': []}
    file_size = os.path.getsize(file_path)

    print(f"üîç ƒêang ƒë√°nh ch·ªâ m·ª•c: {os.path.basename(file_path)} ({file_size/1024/1024:.1f} MB)...")

    try:
        with open(file_path, "rb") as f:
            with mmap.mmap(f.fileno(), length=0, access=mmap.ACCESS_READ) as mm:
                cursor = 0
                KEY_EVENT = b"[Event"
                RES_W = b'[Result "1-0"]'
                RES_L = b'[Result "0-1"]'
                RES_D = b'[Result "1/2-1/2"]'

                with tqdm(total=file_size, unit='B', unit_scale=True, desc="Indexing") as pbar:
                    start_pos = mm.find(KEY_EVENT, cursor)
                    while start_pos != -1:
                        next_pos = mm.find(KEY_EVENT, start_pos + 1)

                        if next_pos == -1:
                            length = file_size - start_pos
                        else:
                            length = next_pos - start_pos

                        head = mm[start_pos : start_pos + min(length, 2048)]

                        if RES_W in head:
                            indices['1-0'].append((start_pos, length))
                        elif RES_L in head:
                            indices['0-1'].append((start_pos, length))
                        elif RES_D in head:
                            indices['1/2-1/2'].append((start_pos, length))

                        processed = (next_pos if next_pos != -1 else file_size) - cursor
                        pbar.update(processed)

                        cursor = next_pos if next_pos != -1 else file_size
                        start_pos = next_pos
    except Exception as e:
        print(f"‚ùå L·ªói trong qu√° tr√¨nh ƒë√°nh ch·ªâ m·ª•c: {e}")
        return {'1-0': [], '0-1': [], '1/2-1/2': []}

    return indices

def process_and_merge():
    if not (os.path.exists(FILE_MAIN) and os.path.exists(FILE_DRAW)):
        print("üö® L·ªói: Kh√¥ng t√¨m th·∫•y √≠t nh·∫•t m·ªôt trong hai file ngu·ªìn. Vui l√≤ng ki·ªÉm tra l·∫°i ƒë∆∞·ªùng d·∫´n.")
        print(f"  MAIN: {FILE_MAIN}")
        print(f"  DRAW: {FILE_DRAW}")
        return

    os.makedirs(OUTPUT_DIR, exist_ok=True)

    idxs_main = scan_pgn_indices_fast(FILE_MAIN)
    pool_w = idxs_main['1-0']
    pool_l = idxs_main['0-1']
    del idxs_main
    gc.collect()

    idxs_draw = scan_pgn_indices_fast(FILE_DRAW)
    pool_d = idxs_draw['1/2-1/2']
    del idxs_draw
    gc.collect()

    print(f"\nüìä KHO D·ªÆ LI·ªÜU:")
    print(f" ¬† - White Wins: {len(pool_w)}")
    print(f" ¬† - Black Wins: {len(pool_l)}")
    print(f" ¬† - Draws: ¬† ¬† ¬†{len(pool_d)}")

    def safe_sample(pool, n, label):
        if len(pool) < n:
            print(f"‚ö†Ô∏è C·∫£nh b√°o: {label} ch·ªâ c√≥ {len(pool)} (C·∫ßn {n}). L·∫•y t·∫•t c·∫£.")
            sampled = pool[:]
            random.shuffle(sampled)
            return sampled
        return random.sample(pool, n)

    final_w = safe_sample(pool_w, TARGET_PER_CLASS, "White")
    final_l = safe_sample(pool_l, TARGET_PER_CLASS, "Black")
    final_d = safe_sample(pool_d, TARGET_PER_CLASS, "Draw")

    del pool_w, pool_l, pool_d
    gc.collect()

    def split_data(lst):
        n = len(lst)
        n1 = int(n * RATIOS[0])
        n2 = int(n * RATIOS[1])
        return lst[:n1], lst[n1:n1+n2], lst[n1+n2:n]

    w_sets = split_data(final_w)
    l_sets = split_data(final_l)
    d_sets = split_data(final_d)

    def tag(lst, src):
        return [(x[0], x[1], src) for x in lst]

    train_items = tag(w_sets[0], FILE_MAIN) + tag(l_sets[0], FILE_MAIN) + tag(d_sets[0], FILE_DRAW)
    valid_items = tag(w_sets[1], FILE_MAIN) + tag(l_sets[1], FILE_MAIN) + tag(d_sets[1], FILE_DRAW)
    test_items = tag(w_sets[2], FILE_MAIN) + tag(l_sets[2], FILE_MAIN) + tag(d_sets[2], FILE_DRAW)

    random.shuffle(train_items)
    random.shuffle(valid_items)
    random.shuffle(test_items)

    print(f"\n‚ú® T·ªîNG K·∫æT B·ªò D·ªÆ LI·ªÜU C√ÇN B·∫∞NG:")
    print(f" ¬† - Train: {len(train_items)} ({len(w_sets[0])} W / {len(l_sets[0])} B / {len(d_sets[0])} D)")
    print(f" ¬† - Valid: {len(valid_items)} ({len(w_sets[1])} W / {len(l_sets[1])} B / {len(d_sets[1])} D)")
    print(f" ¬† - Test: ¬†{len(test_items)} ({len(w_sets[2])} W / {len(l_sets[2])} B / {len(d_sets[2])} D)")

    del w_sets, l_sets, d_sets, final_w, final_l, final_d
    gc.collect()

    print("\nüöÄ ƒêang ghi file...")

    f_main = open(FILE_MAIN, 'rb')
    f_draw = open(FILE_DRAW, 'rb')

    def write_dataset(filename, items):
        path = os.path.join(OUTPUT_DIR, filename)
        print(f"üíæ Ghi {filename} ({len(items)} v√°n)...")

        with open(path, 'wb', buffering=1024*1024) as f_out:
            for start, length, src_file in tqdm(items):
                handle = f_main if src_file == FILE_MAIN else f_draw
                handle.seek(start)
                data = handle.read(length)
                f_out.write(data)

                if not data.endswith(b"\n\n"):
                    f_out.write(b"\n\n")

    write_dataset('train.pgn', train_items)
    write_dataset('validation.pgn', valid_items)
    write_dataset('test.pgn', test_items)

    f_main.close()
    f_draw.close()
    print("\n‚úÖ HO√ÄN T·∫§T TUY·ªÜT ƒê·ªêI!")

# if __name__ == "__main__":
#     process_and_merge()
